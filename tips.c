/**/
//               tips
// ==的比较只能用于整形和字符型，实型的比较要用fabs(x - a) < EPS，EPS需要自己定义为宏常量，一般定义为1e-9.fabs()是取绝对值函数;在一些需要实现判断是否碰撞、接触等函数中也会使用到
//
// 定义为double类型进行scanf时，要用lf，否则会出错
//
//在先后对指向数组首地址的指针进行循环自增赋值与输出时，在scanf与printf代码行之间要再次使指针指向数组首地址，因为在第一次循环自增结束时指针已经指向数组末尾
//
//不论是选择法（打擂）还是冒泡法排序，比较次数都是N-1次
// 
// 变量名称只能包含数字，字母，下划线且不能以数字开头
// 
// 定义结构体的大括号末尾要加分号表示结束
// 
// struct Student相当于是一个类型,就相当于int float之类的，然后可以用typedef来给类型取别名，别名也相当于int float等
// 
// 当对所有数组元素赋初值（即初始化）时，可以省略数组的大小，如int a[]={1,2,3}
// 
// 整形的数值在内存中以补码的形式存放，字符以ASCII码的形式存放（本质也与整形相同，存放ASCII码的补码）
// 
// getchar()是逐个读取，要注意这个特点,每次调用都会向后读取一个字符，因此一般只调用一次getchar
// 
// 字符串的末尾一定会有'\0'作为结束标识符，因此在做字符串操作的时候一定要记得检查是否给字符串末尾加了'\0',比如字符数组str[i]，在对其进行遍历操作之后要进行str[i]='\0'的操作
// 
// 定义字符串数组的时候应在预留一个位置存放\0，否则会出错,比如由键盘输入字符放入数组中，采用char str[5],gets(str)的方法，但由键盘输入的实际只能由四个字符，要留一个位置存放字符'\0'即字符串结束标识符
// 
// 字符由单引号进行声明，字符串由双引号声明
// 
// double类型的变量在使用scanf进行输入的时候要用%lf作为格式占位符，否则会出错
// 
// 使用%取余运算符时，两侧必须为整数
// 
// ==是逻辑运算符且优先级比赋值运算符'='优先级高，表判断，1为真，0为否，例如n=5,a=n==5，那么a的值会是1。不要和=赋值运算符搞混(逻辑运算符> < !=等都是如此，优先级更高)
// 
// 需掌握一个三目运算符,如a>b?a:b，表示的意思是比较a、b大小，若a>b为真，则返回a，否则返回b。本质上为（表达式1）？（表达式2）：（表达式3），若表达式1为真，即返回值为1，则表达式2为整个表达式的取值，否则表达式3为整个表达式的取值
// 
// 关系表达式或逻辑表达式的返回值都为0或1
// 
// switch语句中，case必须是整形常量表达式
// 
// do-while语句中，while语句后面要加分号
// 
// 二维数组在定义的时候可以省略第一维大小即行数，编译器会根据里面大括号的个数自己进行判断，但第二维大小即列数不能省略
// 
// 指数的计算使用pow函数，要包含math.h头文件，使用方法为pow（底数，指数）
// 
// 数组大小必须为常量，包括define的宏常量，但是不能是变量
// 
// 地址是不能进行赋值改变的，比如int a[10],不能a=10。因为a是数组首地址，不能改变
// 
// 文件读写函数fgetc和fputc也和getchar、putchar一样，是一个一个字符读取,用于读取字符，而要读取字符串时,采用文件读写函数fgets和fputs
// 
// 让计算机产生随机数的代码要包含time.h和stdlib.h头文件,且要在main函数中先写下srand((unsigned)time(NULL))，想产生随机数就直接令int a=rand()即可。若要固定范围在[a,b]内，则要int a = rand()%((b-a)+1+b)
// 
// gets函数会自动在末尾加'\0',而fgets不会，因此使用fgets时要将字符串末尾的'\n'换成'\0',即if(str[strlen(str)-1]='\n'    str[strlen(str)-1]='\0')
// 
// 当printf中使用%s作为格式占位符时，会期望得到一个指向字符串的指针，即想要得到字符串数组的首地址
// 
// malloc后面要跟free，且malloc是用来给指针赋值的,要包含stdlib.h头文件。free()要求传入的指针必须是malloc产生的原始地址，不能发生改变。因此，在使用malloc且需要进行指针的自增操作的时候，会将malloc赋值的指针再赋给另一个指针，让另一个指针进行自增，而保持malloc的那个指针不发生变化
// 
// 在自定义函数中，若一维数组为形参，则数组大小省略；若二维数组为形参，则行大小省略（即第一维）
// 
// 任意自定义函数，若以数组为形参，则在main函数调用是都将数组名（即首地址）作为实参进行单项直传递
// 
// 当数组名单独放到sizeof内时，如sizeof(arr)，此时计算的是整个数组的大小
// 
// 二维数组应当看作一维数组进行理解，例如a[3][4],理解为三个一维数组组成的另一个一维数组，分别是a[0][4],a[1][4],a[2][4],直接使用a时表示的是第一行
// 
// sizeof(数组名)计算的是整个数组的大小，(&数组名)是整个数组的指针即数组指针(指向整个数组的指针)，此外的数组名皆为数组首元素地址
// 
// 数组指针的定义方法是（指针类型）（*指针名）[]，比如int(*ptr)[5]=&arr;arr是数组名,此时ptr指向整个数组,ptr+1就会越过整个数组指向数组末尾
// 
// 指向字符串常量的指针只能读，不能修改，存放在内存的只读存储器中;如char *p="hello";char *p1="hello"此时*p指向字符串常量hello的首元素地址即h的地址，而*p1指向的地址也是h的地址，*p=*p1
// 
// 与上一条作比较，char str1[]="hello"与char str2[]="hello"，此时str1!=str2,因为数组内存储的值可以改变，数组是存放在栈上的
// 
// 使用const时，被定义的对象变为常量，即在初始化后其值不可被修改，如const int i=0;不论是i=3;或在for循环中令i自增都是错误的
// 
// const int* ptr为常量指针（指向常量的指针），即指针指向的值不能发生变化，指针可以指向其他地址；int *const ptr为指针常量，指针指向的地址不能变化，指向的值可以变化
// 
// 异或运算，运算符号为^；对两个数转化的二进制数每位进行比较，若相同，则为0，不同则为1，再将计算后的二进制数转化为十进制即为计算结果;例如3(011)^5(101)=6(110)
// 
// 异或运算有交换律、结合律与自反律,即a^a=0;a^0=a;
// 
// 在对一些条件进行判断的时候，可以使用assert（断言函数），须包含头文件<assert.h>，如assert(a<0)，会对表达式进行判断，若为真，则继续执行，若为假，则终止程序
// 
// 使用结构体的时候要注意成员运算符.的优先级比指针的运算符高(*和&)，因此对指针的操作要用括号
// 
// malloc返回的是void*类型的指针，将malloc赋给指针的时候要加强制类型转换
// 
// malloc和free使用之后，要将malloc赋值的指针置空，即将NULL赋给指针
// 
// 在自定义函数中使用形参传递的指针前，要用assert断言，判断指针是否有效(即是否非空)
// 
// 在标准库中strlen返回的是一个size_t(unsigned int)类型，即无符号整形；如strlen("abc")-strlen("abcdef")会等于3而非-3
// 
// 在以字符串指针为形参的自定义函数中，若不会改变指针指向的内容，可使用const，如void function(const char*p){...}
// 
// 使用指针时，最好在定义指针时就将其初始化为NULL
// 
// 整形在内存中的存储形式是以四个字节形式存储，比如3=03 00 00 00, 10=0a 00 00 00，是16进制的数
// 
// 一个字节包含八个比特位
// 
// 内存操作函数memcpy、memset等的参数都是字节数，操作的方式也是操作字节实现的
// 
// 对于匿名结构体类型，只能在声明结构体类型的同时进行变量声明
// 
// sizeof()返回的值是一个size_t类型的值，即无符号整形，在使用时一般要使用强制类型转换
// 
// 内存操作函数（如memcpy等）都在string.h头文件内
//  
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
// 
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
/**/